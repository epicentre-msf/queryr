% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query_vec.R
\name{query_vec}
\alias{query_vec}
\title{Data validation queries vectorized over multiple query expressions}
\usage{
query_vec(
  x,
  cond,
  element,
  name,
  cols_base,
  name_col = "query_id",
  join_type = "left",
  join_by = NULL,
  pivot_var = "variable",
  pivot_val = "value",
  as_chr = TRUE
)
}
\arguments{
\item{x}{A data frame or a list of data frames to query. If a single data
frame will vectorize with \code{\link{query}}, whereas given a list of data frames
will use \code{\link{query_list}}.}

\item{cond}{Character vector of expressions to evaluate with respect to
variables within \code{x}.}

\item{element}{If \code{x} is a list of data frames, the names or integer indexes
of the focal list element of \code{x} corresponding to each query expression
(i.e. each element of \code{cond}). Only used if \code{x} is a list of data frames
(see \code{\link{query_list}}).}

\item{name}{(Optional) Character vector giving query names/IDs for each of
the expressions within \code{cond}. If missing the expressions themselves (in
string format) are used as names.}

\item{cols_base}{(Optional) Tidy-selection of other columns within \code{x} (or
\code{x[[element]]}) to retain in the final output. Can be set for an entire
session using option "queryr_cols_base", e.g. \code{options(queryr_cols_base = quote(id:site))}.}

\item{name_col}{Column name for the query names/IDs. Defaults to "query_id".}

\item{join_type}{If \code{x} is a list of data frames and \code{cond} references
variables within elements of \code{x} apart from \code{x[[element]]}, what type of
join should be used to join the relevant elements? Options are "left" (the
default) and "inner". Based on dplyr \code{\link[dplyr]{join}} types. Can
specify different join types for different query expressions by passing a
vector the same length as \code{cond}.}

\item{join_by}{A character vector of variables to join by, or list of vectors
the same length as \code{cond}. If the join key columns have different names in
\code{x[[element]]} and \code{x[[other]]}, use a named vector. For example, \code{join_by = c("a" = "b")} will match \code{x[[element]]$a} to \code{x[[other]]$b}. Can specify
different join columns for different query expressions by passing a \emph{list}
of vectors the same length as \code{cond}.}

\item{pivot_var}{Prefix for pivoted variable column(s). Defaults to
"variable".}

\item{pivot_val}{Prefix for pivoted value column(s). Defaults to "value".}

\item{as_chr}{Logical indicating whether to coerce the columns referenced in
the query expression(s) to character prior to returning. This enables
row-binding multiple queries with variables of different classes. Defaults
to \code{TRUE}.}
}
\value{
A data frame reflecting the rows of \code{data} that match the given queries.
Returned columns include:
\itemize{
\item query name/ID column (name taken from argument \code{name_col})
\item (optional) columns matched by argument \code{cols_base}
\item columns referenced within the query expressions, pivoted to long form
}
}
\description{
Data validation queries with \code{\link{query}} or \code{\link{query_list}}, but vectorized over
a set of query expressions in string format (and optionally a corresponding
vector of query names/IDs). Results of the multiple queries are stacked and
returned in a single tidy data frame, with columns referenced in the query
expressions pivoted to long-form (e.g. "variable1", "value1", "variable2",
"value2", ...).
}
\examples{
data(ll)          # example dataset, an epidemiological linelist
data(ll_queries)  # example data frame defining queries to run on ll

# run all queries defined in ll_queries
query_vec(
  ll,
  cond = ll_queries$query,
  name = ll_queries$query_id,
  cols_base = c(id, site)
)

}
\seealso{
\code{\link{query}}
}
