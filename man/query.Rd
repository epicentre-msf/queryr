% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query.R
\name{query}
\alias{query}
\title{Data validation queries with tidy, stackable output}
\usage{
query(
  data,
  cond,
  cols_dotx,
  cols_base,
  qcol = "query",
  qval = NULL,
  pivot_long = TRUE,
  pivot_var = "variable",
  pivot_val = "value",
  as_chr = TRUE,
  count = FALSE
)
}
\arguments{
\item{data}{A data frame}

\item{cond}{An expression to evaluate with respect to variables within
\code{data}. Can specify multiple variables using a "\code{.x}" selector within the
expression (e.g. \code{.x > 0}) and then specifying the columns that \code{.x} refers
to with argument \code{cols_dotx}.}

\item{cols_dotx}{Tidy-selection of one or more columns represented by a .x
selector. Only used if \code{cond} contains a .x selector. See section \strong{Using a
.x selector} below.}

\item{cols_base}{(Optional) Tidy-selection of other columns within \code{data} to
retain in the output. Can optionally be set for an entire session using
option "queryr_cols_base", e.g. \code{options(queryr_cols_base = quote(id:site))}.}

\item{qcol}{(Optional) Name of query identifier column. Defaults to "query".
Only appended if argument \code{qval} is specified.}

\item{qval}{(Optional) Value of query identifier column}

\item{pivot_long}{Logical indicating whether to pivot the variables
referenced within \code{cond} to a long (i.e. stackable) format, with default
column names "variable1", "value1", "variable2", "value2", ... Defaults to
\code{TRUE}.}

\item{pivot_var}{Prefix for pivoted variable column(s). Defaults to
"variable". Only used if \code{pivot_long = TRUE}.}

\item{pivot_val}{Prefix for pivoted value column(s). Defaults to "value".
Only used if \code{pivot_long = TRUE}.}

\item{as_chr}{Logical indicating whether to coerce the columns referenced in
the query expression \code{cond} to character prior to returning. This enables
row-binding multiple queries with variables of different classes, but is
only important if \code{pivot_long = TRUE}. Defaults to \code{TRUE}.}

\item{count}{Logical indicating whether to summarize the output by counting
the number of unique combinations across all returned columns (with count
column "n"). Defaults to \code{FALSE}.}
}
\value{
A data frame reflecting the rows of \code{data} that match the given query.
Returned columns include:
\itemize{
\item (optional) query ID column \code{qcol} (if \code{qval} is specified)
\item (optional) columns matched by argument \code{cols_base}
\item columns referenced within the query expression (pivoted to long form by
default)
\item (optional) count column "n" (if \code{count} = TRUE)
}
}
\description{
Find observations within a data frame matching a given query (a logical
expression relating to one or more variables), and return tidy output that
can be stacked across different queries on different variables. Stackability
is achieved by pivoting the columns indicated in the query expression to
long-form, e.g. "variable1", "value1", "variable2", "value2", ...

The query expression can optionally incorporate a "\code{.x}" selector to refer to
a set of multiple variables, which is specified separately using
tidy-selection (see section \strong{Using a .x selector}).

By default, only the data columns referenced in the query expression are
returned, but additional columns can optionally be added with argument
\code{cols_base}.
}
\section{Using a .x selector}{

A "\code{.x}" selector within the query expression \code{cond} represents a set of
multiple variables, which are specified separately using argument
\code{cols_dotx}. When \code{cond} contains a \code{.x} selector, the query expression is
evaluated repeatedly with each relevant variable from \code{cols_dotx}
individually substituted into the \code{.x} position of the expression. The
results of these multiple 'subqueries' are then combined with
\code{\link[dplyr:bind_rows]{dplyr::bind_rows}}.

Note that if a .x selector is used with argument \code{pivot_long = FALSE}, the
row-binding of multiple subqueries may result in a sparse output with
respect to the variables represented by \code{.x}, because for each subquery only
the columns matched by expression \code{cond} are returned.
}

\examples{
# load example dataset, an epidemiological 'linelist'
data(ll)

# find observations where date_exit is earlier than date_admit
query(
  ll,
  date_exit < date_admit,
  cols_base = id:site
)

# find any date value in the future using a .x column selector
query(
  ll,
  .x > Sys.Date(),
  cols_dotx = starts_with("date"),
  cols_base = id:site
)

# include a query identifier column in the output
query(
  ll,
  .x > Sys.Date(),
  cols_dotx = starts_with("date"),
  cols_base = id:site,
  qval = "DATES_01"
)

# incorporate an external object into the query expression
valid_age_units <- c("Years", "Months", "Weeks", "Days")

query(
  ll,
  !age_unit \%in\% valid_age_units,
  cols_base = id:site,
)

}
