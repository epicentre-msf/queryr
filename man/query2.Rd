% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query2.R
\name{query2}
\alias{query2}
\title{Data validation queries across two data frames}
\usage{
query2(
  data1,
  data2,
  cond1,
  cond2,
  cols_base1,
  cols_base2,
  join_type,
  join_by,
  cond3,
  pivot_long = TRUE,
  pivot_var = "variable",
  pivot_val = "value",
  as_chr = TRUE
)
}
\arguments{
\item{data1}{Data frame to query (#1)}

\item{data2}{Data frame to query (#2)}

\item{cond1}{(Optional) Expression to evaluate with respect to \code{data1}. If
missing will be set to \code{TRUE} to select all rows.}

\item{cond2}{(Optional) Expression to evaluate with respect to \code{data2}. If
missing will be set to \code{TRUE} to select all rows.}

\item{cols_base1}{(Optional) Tidy-selection of other columns within \code{data1}
to retain in the final output. Can be set for an entire session using
option "queryr_cols_base", e.g. \code{options(queryr_cols_base = quote(id:site))}.}

\item{cols_base2}{(Optional) Tidy-selection of other columns within \code{data2}
to retain in the final output.}

\item{join_type}{How to join the output from the two initial queries ("semi", "anti",
"left", or "inner"). Based on dplyr \code{\link[dplyr]{join}} types.}

\item{join_by}{A character vector of variables to join by. If the join key
columns have different names in \code{data1} and \code{data2}, use a named vector.
For example, \code{by = c("a" = "b")} will match \code{data1$a} to \code{data2$b}.}

\item{cond3}{(Optional) Expression to evaluate with respect to the joined
output of the two initial queries. If missing will be set to \code{TRUE} to
select all rows.

Note that if \code{join_type} is a filtering join ("anti" or "semi"), only
variables from \code{data1} can be referenced in \code{cond3} (referencing a variable
that only exists in \code{data2} will result in an error).

If \code{join_type} is instead a mutating join ("left" or "inner"), all
variables from \code{data1} and \code{data2} will be available to \code{cond3}, even if
not otherwise referenced with \code{cond1}/\code{cond2} or \code{cols_base1}/\code{cols_base2}.}

\item{pivot_long}{Logical indicating whether to pivot the variables
referenced within the query expression(s) to a long (i.e. stackable)
format, with default column names "variable1", "value1", "variable2",
"value2", ... Defaults to \code{TRUE}. If \code{cond3} is specified and \code{pivot_long}
is \code{TRUE}, the pivot happens only in the final query (i.e. \code{cond3}).}

\item{pivot_var}{Prefix for pivoted variable column(s). Defaults to
"variable". Only used if \code{pivot_long = TRUE}.}

\item{pivot_val}{Prefix for pivoted value column(s). Defaults to "value".
Only used if \code{pivot_long = TRUE}.}

\item{as_chr}{Logical indicating whether to coerce the columns referenced in
the query expression(s) to character prior to returning. This enables
row-binding multiple queries with variables of different classes, but is
only important if \code{pivot_long = TRUE}. Defaults to \code{TRUE}.}
}
\value{
A data frame reflecting the rows of \code{data1} that match the given
query. Returned columns include:
\itemize{
\item Columns matched by argument \code{cols_base1}
\item Columns matched by argument \code{cols_base2} (only if join type is "left" or
"inner")
\item Columns referenced within the relevant condition statements (pivoted to
long form by default). \cr

If the join type is a mutating join ("left" or "inner"), variables from
\code{data1} or \code{data2} referenced in \emph{any} of the condition statements
(\code{cond1}, \code{cond2}, or \code{cond3}) will appear in the output. However, with a
filtering join ("anti" or "semi") only variables from \code{data1} will appear
in the output.
}
}
\description{
Find observations matching a query that concerns two data frames, and return
tidy, stackable output. Entails three steps:
\enumerate{
\item separately query each of the two data frames using
\code{\link{query}}
\item combine the resulting query outputs based on a given join type (semi,
anti, left, or inner)
\item execute a third query on the joined output
}

Each of the query steps is optional â€” unspecified query expressions are
replaced with \code{TRUE} such that all rows of the relevant input are returned.
}
\examples{
# example datasets: two related epidemiological linelists
data(ll)  # ll from treatment center (all cases, confirmed and non-confirmed)
data(sll) # summary linelist (only confirmed/probable cases)

# find patients in ll that don't appear in sll
query2(
  ll,
  sll,
  cols_base1 = c(id, site, status),
  join_type = "anti",
  join_by = c("id" = "tc_id")
)

# find patients with different outcome status in ll vs sll
query2(
  ll,
  sll,
  cols_base1 = id:site,
  join_type = "inner",
  join_by = c("id" = "tc_id"),
  cond3 = status != sll_status
)

}
